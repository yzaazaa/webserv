#include <iostream>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <fcntl.h>
#include <vector>
#include <sys/select.h>

int main()
{
	int server_socketfd = socket(AF_INET, SOCK_STREAM, 0);

	if (server_socketfd == -1)
	{
		perror("Socket Opening");
		return (1);
	}
	

	int opt = 1;
	if (setsockopt(server_socketfd, SOL_SOCKET,SO_REUSEADDR, (char*)&opt, sizeof opt) < 0)
	{
		perror("setSocketopt");
		return (1);
	}


	sockaddr_in	serverAddress;
	serverAddress.sin_family = AF_INET;
	serverAddress.sin_port = htons(1234);
	serverAddress.sin_addr.s_addr = INADDR_ANY;
	//inet_pton(AF_INET, ip, &serverAddr.sin_addr);

	if (bind(server_socketfd, (struct sockaddr*)&serverAddress, sizeof(serverAddress)) == -1)
	{
		perror("Socket Binding");
		return (1);
	}

	if (listen(server_socketfd, 5) == -1)
	{
		perror("Socket listening");
		return (1);
	}


	// Set server socket to non-blocking mode
    int flags = fcntl(server_socketfd, F_GETFL, 0);
    if (flags == -1)
	{
        perror("fcntl F_GETFL");
        return 1;
    }
    if (fcntl(server_socketfd, F_SETFL, flags | O_NONBLOCK) == -1)
	{
        perror("fcntl F_SETFL O_NONBLOCK");
        return 1;
    }

	
	fd_set readfds;
	std::vector<int> clientSockets;
	int maxfd = server_socketfd;
	while (true)
    {
        FD_ZERO(&readfds);
        FD_SET(server_socketfd, &readfds);

        // Add all client sockets to the set
        for (int clientfd : clientSockets)
        {
            FD_SET(clientfd, &readfds);
            if (clientfd > maxfd)
            {
                maxfd = clientfd;
            }
        }

        if (select(maxfd + 1, &readfds, nullptr, nullptr, nullptr) == -1)
        {
            perror("Select");
            return 1;
        }

		//std::cout << "select skipped" << std::endl;
		//std::cout << "loop" << std::endl;

        // Check if there is a new connection
        if (FD_ISSET(server_socketfd, &readfds))
        {
            sockaddr_in clientAddress;
            socklen_t clientAddressLen = sizeof(clientAddress);
            
            int clientfd = accept(server_socketfd, (struct sockaddr*)&clientAddress, &clientAddressLen);
            if (clientfd == -1)
            {
                perror("Accept");
                continue;
            }
				//std::cout << "Accept" << std::endl;

            clientSockets.push_back(clientfd);
            std::cout << "New client connected." << std::endl;
        }

        // Check all client sockets for readability
        for (int i = 0; i < clientSockets.size(); ++i)
        {
            int clientfd = clientSockets[i];
            if (FD_ISSET(clientfd, &readfds))
            {
				//std::cout << "Read" << std::endl;
                char buffer[1024] = { 0 };
                ssize_t bytesRead = recv(clientfd, buffer, sizeof(buffer) - 1, 0);
                if (bytesRead <= 0)
                {
                    if (bytesRead == 0)
                    {
                        std::cout << "Client disconnected." << std::endl;
                    }
                    else
                    {
                        perror("Receive");
                    }
                    close(clientfd);
                    clientSockets.erase(clientSockets.begin() + i);
                    --i; // Adjust index after removal
                }
                else
                {
                    buffer[bytesRead] = '\0'; // Null-terminate the buffer
                    std::cout << "Message from client: " << buffer << std::endl;
				}
            }
        }
    }
	

	close(server_socketfd);
	return (0);
	
}